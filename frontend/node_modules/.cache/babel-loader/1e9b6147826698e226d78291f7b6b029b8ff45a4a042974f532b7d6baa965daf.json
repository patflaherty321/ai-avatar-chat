{"ast":null,"code":"import React,{useEffect,useRef,useState}from'react';import{useRive,useStateMachineInput}from'@rive-app/react-canvas';import{jsx as _jsx}from\"react/jsx-runtime\";function Avatar(_ref){let{isActive,isTalking,isThinking,visemes,audioUrl,scale=1.5// Default to 150%, can be overridden\n}=_ref;console.log(`ðŸŽ­ Avatar Component: Received scale=${scale}`);const audioRef=useRef(null);const visemeTimersRef=useRef([]);// Remove dynamic scaling - keep avatar at consistent 170% scale\n// const calculateScale = () => {\n//   // Removed to maintain consistent avatar size across all screen sizes\n// };\n// Remove resize listener since we're not scaling anymore\n// useEffect(() => {\n//   // Removed dynamic scaling\n// }, []);\n// Initialize Rive\nconst{RiveComponent,rive}=useRive({src:'/avatar.riv',stateMachines:'State Machine 1',autoplay:true});// Get state machine inputs for controlling visemes\nconst visemeInput=useStateMachineInput(rive,'State Machine 1','numViseme');const speakingInput=useStateMachineInput(rive,'State Machine 1','IsSpeaking');console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.1 *** Component rendered with props:',{isActive,isTalking,isThinking,visemes:visemes===null||visemes===void 0?void 0:visemes.length,audioUrl,riveLoaded:!!rive,visemeInput:!!visemeInput,speakingInput:!!speakingInput});// Debug Rive loading\nuseEffect(()=>{if(rive){console.log('[RIVE AVATAR] âœ… Rive loaded successfully');}else{console.log('[RIVE AVATAR] â³ Waiting for Rive to load...');}},[rive]);useEffect(()=>{if(visemeInput){console.log('[RIVE AVATAR] âœ… Viseme input connected');}if(speakingInput){console.log('[RIVE AVATAR] âœ… Speaking input connected');}},[visemeInput,speakingInput]);// Control speaking state\nuseEffect(()=>{if(speakingInput){speakingInput.value=isTalking;console.log('[RIVE AVATAR] Set IsSpeaking to:',isTalking);}},[isTalking,speakingInput]);// Handle synchronized audio and viseme animation\nuseEffect(()=>{var _audioRef$current,_audioRef$current$dat;// Clear any existing timers\nvisemeTimersRef.current.forEach(clearTimeout);visemeTimersRef.current=[];// Cleanup previous audio\nif(audioRef.current){audioRef.current.pause();audioRef.current.currentTime=0;audioRef.current=null;}// Only start if we have all required data and haven't played this audio yet\nif(!audioUrl||!visemeInput||!visemes||visemes.length===0){// Reset to neutral when not talking\nif(visemeInput&&!isTalking){visemeInput.value=0;}return;}// Prevent duplicate playback by checking if this is the same audio\nconst audioKey=`${audioUrl}_${visemes.length}`;if(((_audioRef$current=audioRef.current)===null||_audioRef$current===void 0?void 0:(_audioRef$current$dat=_audioRef$current.dataset)===null||_audioRef$current$dat===void 0?void 0:_audioRef$current$dat.audioKey)===audioKey){console.log('[RIVE AVATAR] Skipping duplicate audio:',audioKey);return;}console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.0 *** Starting synchronized audio + lip sync with',visemes.length,'visemes');// Create audio element\nconst audio=new Audio();const fullAudioUrl=audioUrl.startsWith('http')?audioUrl:`http://localhost:3006${audioUrl}`;audio.src=fullAudioUrl;audio.volume=1.0;audio.dataset.audioKey=audioKey;// Mark this audio to prevent duplicates\naudioRef.current=audio;// Setup audio event listeners\naudio.addEventListener('ended',()=>{console.log('[RIVE AVATAR] Audio playback ended');});audio.addEventListener('error',e=>{console.error('[RIVE AVATAR] Audio error:',e);});// Coordinate audio and viseme start with REAL-TIME SYNC\nconst startSynchronizedPlayback=async()=>{try{console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.1 *** Starting audio + viseme synchronization');// Start audio first\nawait audio.play();console.log('[RIVE AVATAR] Audio started successfully');// Use real-time sync instead of pre-scheduling\nconst syncVisemesToAudio=()=>{if(!audio||!visemeInput)return;const currentTimeMs=audio.currentTime*1000;// Convert to milliseconds\n// Find the current viseme based on audio time\nlet currentViseme=null;for(const viseme of visemes){const visemeTimeMs=viseme.timeMs||0;if(currentTimeMs>=visemeTimeMs){currentViseme=viseme;}else{break;// Visemes should be in chronological order\n}}if(currentViseme){const visemeId=currentViseme.visemeId||currentViseme.id||0;const expectedViseme=Math.max(0,Math.min(21,visemeId));// Only update if the viseme has changed\nif(visemeInput.value!==expectedViseme){visemeInput.value=expectedViseme;console.log(`[RIVE AVATAR] Real-time sync: viseme ${expectedViseme} at ${Math.round(currentTimeMs)}ms`);}}// Continue syncing if audio is still playing\nif(!audio.paused&&!audio.ended){requestAnimationFrame(syncVisemesToAudio);}else{// Audio finished, reset to neutral\nif(visemeInput){visemeInput.value=0;}console.log('[RIVE AVATAR] Real-time sync completed');}};// Start the real-time synchronization\nsyncVisemesToAudio();}catch(err){console.error('[RIVE AVATAR] Synchronized playback error:',err);if(err.name==='NotAllowedError'){console.log('[RIVE AVATAR] Audio autoplay blocked. User interaction required.');}}};// Start the synchronized playback\nstartSynchronizedPlayback();// Cleanup function\nreturn()=>{visemeTimersRef.current.forEach(clearTimeout);visemeTimersRef.current=[];if(audioRef.current){audioRef.current.pause();audioRef.current.currentTime=0;audioRef.current=null;}if(visemeInput){visemeInput.value=0;}};},[audioUrl,visemes,visemeInput]);// Removed isTalking from dependencies to prevent re-triggering\nreturn/*#__PURE__*/_jsx(\"div\",{style:{position:'absolute',top:0,left:0,right:0,bottom:0,width:'100%',height:'100%',display:'flex',alignItems:'center',justifyContent:'center',borderRadius:'inherit',// Inherit the border radius from parent\noverflow:'hidden'// Ensure content is clipped to rounded corners\n},children:/*#__PURE__*/_jsx(RiveComponent,{style:{width:`${scale*100}%`,// Use dynamic scale\nheight:`${scale*100}%`,// Use dynamic scale\nminWidth:'120%',// Ensure minimum coverage\nminHeight:'120%',// Ensure minimum coverage\nobjectFit:'cover',// Cover the entire container\nborderRadius:'inherit',// Inherit the border radius\ntransform:'scale(1.1)'// Additional scale to eliminate any remaining gaps\n}})});}export default Avatar;","map":{"version":3,"names":["React","useEffect","useRef","useState","useRive","useStateMachineInput","jsx","_jsx","Avatar","_ref","isActive","isTalking","isThinking","visemes","audioUrl","scale","console","log","audioRef","visemeTimersRef","RiveComponent","rive","src","stateMachines","autoplay","visemeInput","speakingInput","length","riveLoaded","value","_audioRef$current","_audioRef$current$dat","current","forEach","clearTimeout","pause","currentTime","audioKey","dataset","audio","Audio","fullAudioUrl","startsWith","volume","addEventListener","e","error","startSynchronizedPlayback","play","syncVisemesToAudio","currentTimeMs","currentViseme","viseme","visemeTimeMs","timeMs","visemeId","id","expectedViseme","Math","max","min","round","paused","ended","requestAnimationFrame","err","name","style","position","top","left","right","bottom","width","height","display","alignItems","justifyContent","borderRadius","overflow","children","minWidth","minHeight","objectFit","transform"],"sources":["/Users/pat/Desktop/Rive-Avatar-Web/ai-avatar-chat-production/frontend/src/Avatar.jsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport { useRive, useStateMachineInput } from '@rive-app/react-canvas';\n\nfunction Avatar({ \n  isActive, \n  isTalking, \n  isThinking, \n  visemes, \n  audioUrl,\n  scale = 1.5 // Default to 150%, can be overridden\n}) {\n  console.log(`ðŸŽ­ Avatar Component: Received scale=${scale}`);\n  \n  const audioRef = useRef(null);\n  const visemeTimersRef = useRef([]);\n\n  // Remove dynamic scaling - keep avatar at consistent 170% scale\n  // const calculateScale = () => {\n  //   // Removed to maintain consistent avatar size across all screen sizes\n  // };\n\n  // Remove resize listener since we're not scaling anymore\n  // useEffect(() => {\n  //   // Removed dynamic scaling\n  // }, []);\n\n  // Initialize Rive\n  const { RiveComponent, rive } = useRive({\n    src: '/avatar.riv',\n    stateMachines: 'State Machine 1',\n    autoplay: true,\n  });\n\n  // Get state machine inputs for controlling visemes\n  const visemeInput = useStateMachineInput(rive, 'State Machine 1', 'numViseme');\n  const speakingInput = useStateMachineInput(rive, 'State Machine 1', 'IsSpeaking');\n\n  console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.1 *** Component rendered with props:', { \n    isActive, \n    isTalking, \n    isThinking, \n    visemes: visemes?.length, \n    audioUrl,\n    riveLoaded: !!rive,\n    visemeInput: !!visemeInput,\n    speakingInput: !!speakingInput\n  });\n\n  // Debug Rive loading\n  useEffect(() => {\n    if (rive) {\n      console.log('[RIVE AVATAR] âœ… Rive loaded successfully');\n    } else {\n      console.log('[RIVE AVATAR] â³ Waiting for Rive to load...');\n    }\n  }, [rive]);\n\n  useEffect(() => {\n    if (visemeInput) {\n      console.log('[RIVE AVATAR] âœ… Viseme input connected');\n    }\n    if (speakingInput) {\n      console.log('[RIVE AVATAR] âœ… Speaking input connected');\n    }\n  }, [visemeInput, speakingInput]);\n\n  // Control speaking state\n  useEffect(() => {\n    if (speakingInput) {\n      speakingInput.value = isTalking;\n      console.log('[RIVE AVATAR] Set IsSpeaking to:', isTalking);\n    }\n  }, [isTalking, speakingInput]);\n\n  // Handle synchronized audio and viseme animation\n  useEffect(() => {\n    // Clear any existing timers\n    visemeTimersRef.current.forEach(clearTimeout);\n    visemeTimersRef.current = [];\n    \n    // Cleanup previous audio\n    if (audioRef.current) {\n      audioRef.current.pause();\n      audioRef.current.currentTime = 0;\n      audioRef.current = null;\n    }\n\n    // Only start if we have all required data and haven't played this audio yet\n    if (!audioUrl || !visemeInput || !visemes || visemes.length === 0) {\n      // Reset to neutral when not talking\n      if (visemeInput && !isTalking) {\n        visemeInput.value = 0;\n      }\n      return;\n    }\n\n    // Prevent duplicate playback by checking if this is the same audio\n    const audioKey = `${audioUrl}_${visemes.length}`;\n    if (audioRef.current?.dataset?.audioKey === audioKey) {\n      console.log('[RIVE AVATAR] Skipping duplicate audio:', audioKey);\n      return;\n    }\n\n    console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.0 *** Starting synchronized audio + lip sync with', visemes.length, 'visemes');\n    \n    // Create audio element\n    const audio = new Audio();\n    const fullAudioUrl = audioUrl.startsWith('http') ? audioUrl : `http://localhost:3006${audioUrl}`;\n    audio.src = fullAudioUrl;\n    audio.volume = 1.0;\n    audio.dataset.audioKey = audioKey; // Mark this audio to prevent duplicates\n    audioRef.current = audio;\n\n    // Setup audio event listeners\n    audio.addEventListener('ended', () => {\n      console.log('[RIVE AVATAR] Audio playback ended');\n    });\n    \n    audio.addEventListener('error', (e) => {\n      console.error('[RIVE AVATAR] Audio error:', e);\n    });\n\n    // Coordinate audio and viseme start with REAL-TIME SYNC\n    const startSynchronizedPlayback = async () => {\n      try {\n        console.log('[RIVE AVATAR] *** REAL-TIME SYNC v5.1 *** Starting audio + viseme synchronization');\n        \n        // Start audio first\n        await audio.play();\n        console.log('[RIVE AVATAR] Audio started successfully');\n        \n        // Use real-time sync instead of pre-scheduling\n        const syncVisemesToAudio = () => {\n          if (!audio || !visemeInput) return;\n          \n          const currentTimeMs = audio.currentTime * 1000; // Convert to milliseconds\n          \n          // Find the current viseme based on audio time\n          let currentViseme = null;\n          for (const viseme of visemes) {\n            const visemeTimeMs = viseme.timeMs || 0;\n            if (currentTimeMs >= visemeTimeMs) {\n              currentViseme = viseme;\n            } else {\n              break; // Visemes should be in chronological order\n            }\n          }\n          \n          if (currentViseme) {\n            const visemeId = currentViseme.visemeId || currentViseme.id || 0;\n            const expectedViseme = Math.max(0, Math.min(21, visemeId));\n            \n            // Only update if the viseme has changed\n            if (visemeInput.value !== expectedViseme) {\n              visemeInput.value = expectedViseme;\n              console.log(`[RIVE AVATAR] Real-time sync: viseme ${expectedViseme} at ${Math.round(currentTimeMs)}ms`);\n            }\n          }\n          \n          // Continue syncing if audio is still playing\n          if (!audio.paused && !audio.ended) {\n            requestAnimationFrame(syncVisemesToAudio);\n          } else {\n            // Audio finished, reset to neutral\n            if (visemeInput) {\n              visemeInput.value = 0;\n            }\n            console.log('[RIVE AVATAR] Real-time sync completed');\n          }\n        };\n        \n        // Start the real-time synchronization\n        syncVisemesToAudio();\n        \n      } catch (err) {\n        console.error('[RIVE AVATAR] Synchronized playback error:', err);\n        if (err.name === 'NotAllowedError') {\n          console.log('[RIVE AVATAR] Audio autoplay blocked. User interaction required.');\n        }\n      }\n    };\n\n    // Start the synchronized playback\n    startSynchronizedPlayback();\n\n    // Cleanup function\n    return () => {\n      visemeTimersRef.current.forEach(clearTimeout);\n      visemeTimersRef.current = [];\n      if (audioRef.current) {\n        audioRef.current.pause();\n        audioRef.current.currentTime = 0;\n        audioRef.current = null;\n      }\n      if (visemeInput) {\n        visemeInput.value = 0;\n      }\n    };\n  }, [audioUrl, visemes, visemeInput]); // Removed isTalking from dependencies to prevent re-triggering\n\n  return (\n    <div style={{\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0,\n      width: '100%',\n      height: '100%',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      borderRadius: 'inherit', // Inherit the border radius from parent\n      overflow: 'hidden' // Ensure content is clipped to rounded corners\n    }}>\n      <RiveComponent style={{\n        width: `${scale * 100}%`,  // Use dynamic scale\n        height: `${scale * 100}%`, // Use dynamic scale\n        minWidth: '120%', // Ensure minimum coverage\n        minHeight: '120%', // Ensure minimum coverage\n        objectFit: 'cover', // Cover the entire container\n        borderRadius: 'inherit', // Inherit the border radius\n        transform: 'scale(1.1)' // Additional scale to eliminate any remaining gaps\n      }} />\n    </div>\n  );\n}\n\nexport default Avatar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}